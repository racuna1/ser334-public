#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\branch soln
\selected 0
\filename_suffix 0
\color #faf0e6
\end_branch
\branch blank
\selected 1
\filename_suffix 0
\color #faf0e6
\end_branch
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.54cm
\topmargin 2.54cm
\rightmargin 2.54cm
\bottommargin 2.54cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\noindent
Arizona State University
\begin_inset space \hfill{}
\end_inset

SER334: Operating Systems & Networks
\end_layout

\begin_layout Standard
\noindent
UGTA Lisonbee (3), Lecturer Acuña (2)
\begin_inset space \hfill{}
\end_inset

Revised 1/26/2019
\end_layout

\begin_layout Standard
\noindent
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard

\size huge
Unit 3 Sample Problems - C Programming III
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
In this sample problem set, we will practice advanced concepts in the C
 programming language.
\end_layout

\begin_layout Itemize
Length: (pending in-class use data)
\end_layout

\begin_layout Itemize
Questions: Q1-Q4.
\end_layout

\begin_layout Standard
\begin_inset Formula $\;$
\end_inset


\end_layout

\begin_layout Standard

\series bold
Learning Objectives:
\end_layout

\begin_layout Enumerate
Understand how the preprocessor works in C.
 
\begin_inset CommandInset label
LatexCommand label
name "lo_preprocessor"

\end_inset


\end_layout

\begin_layout Enumerate
Apply multiple source files, the preprocessor, and the linker to construct
 modular programs.
 
\begin_inset CommandInset label
LatexCommand label
name "lo_modularprog"

\end_inset


\end_layout

\begin_layout Enumerate
Apply procedural programming techniques to perform object-oriented programming.
 
\begin_inset CommandInset label
LatexCommand label
name "lo_oopinc"

\end_inset


\end_layout

\begin_layout Enumerate
Apply a file format specification and a file I/O library to read and write
 binary files.
 
\begin_inset CommandInset label
LatexCommand label
name "lo_binaryfiles"

\end_inset


\end_layout

\begin_layout Section*

\series bold
\size larger
\begin_inset Formula $\;\;\,\;$
\end_inset

The Preprocessor 
\end_layout

\begin_layout Enumerate
[Lisonbee] Below is some partially implemented C code.
 Using it as a template, create macros based on the instructions given in
 the comments.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status open

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

// Create a macro called AMOUNT_1 and assign it any integer value.
\end_layout

\begin_layout Plain Layout

#define
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Create a macro called AMOUNT_2 and assign it any integer value.
\end_layout

\begin_layout Plain Layout

#define
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Create a macro called DIFFERENCE with a precision of two decimal places
 
\end_layout

\begin_layout Plain Layout

// and assign it's value to be the result of AMOUNT_1 minus AMOUNT_2.
\end_layout

\begin_layout Plain Layout

#define
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Determine if the AMOUNT_1 is greater than AMOUNT_2 using DIFFERENCE (if
\end_layout

\begin_layout Plain Layout

// DIFFERENCE is greater than 0, then AMOUNT_2 is larger, vice versa).
\end_layout

\begin_layout Plain Layout

#if (                                                      )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  //If this condition is true, define a macro called OUTPUT and assign
\end_layout

\begin_layout Plain Layout

  //it a value of 1.
\end_layout

\begin_layout Plain Layout

  #define
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#else 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  //If this condition is false, define a macro called OUTPUT and assign
\end_layout

\begin_layout Plain Layout

  //it a value of 0.
\end_layout

\begin_layout Plain Layout

  #define
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#endif 
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status open

\begin_layout Standard

\series bold
Ans: [Lisonbee]
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

// Create a macro called AMOUNT_1 and assign it any integer value.
\end_layout

\begin_layout Plain Layout

#define AMOUNT_1 123
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Create a macro called AMOUNT_2 and assign it any integer value.
\end_layout

\begin_layout Plain Layout

#define AMOUNT_2 234
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Create a macro called DIFFERENCE with a precision of two decimal places
 
\end_layout

\begin_layout Plain Layout

// and assign it's value to be the result of AMOUNT_1 minus AMOUNT_2.
\end_layout

\begin_layout Plain Layout

#define DIFFERENCE (AMOUNT_1 - AMOUNT_2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Determine if the AMOUNT_1 is greater than AMOUNT_2 using DIFFERENCE (if
\end_layout

\begin_layout Plain Layout

// DIFFERENCE is greater than 0, then AMOUNT_2 is larger, vice versa).
\end_layout

\begin_layout Plain Layout

#if ( DIFFERENCE > 0 )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  //If this condition is true, define a macro called OUTPUT and assign
\end_layout

\begin_layout Plain Layout

  //it a value of 1.
\end_layout

\begin_layout Plain Layout

  #define OUTPUT 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#else 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  //If this condition is false, define a macro called OUTPUT and assign
\end_layout

\begin_layout Plain Layout

  //it a value of 0.
\end_layout

\begin_layout Plain Layout

  #define OUTPUT 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#endif 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section*

\series bold
Object-Oriented Programming
\end_layout

\end_deeper
\begin_layout Enumerate
[Lisonbee] Implement a string ADT using a struct and six functions.
 At its most simple, a string is an array of characters that is terminated
 by a null terminator.
 Although having a dedicated string type is generally an OOP concept, we
 can still implement it in C.
 The struct should use variables to represent an internal data structure,
 and the length of the string.
 Create six functions: string_create, string_destroy, string_append, string_subs
tring, string_length, and string_display.
 Describes of each are shown on the next page.
 NOTE: you may only use stdlib.h and stdio.h for this problem; you should
 include them in your header file.
\end_layout

\begin_deeper
\begin_layout Standard
Your ADT will be structured with three files: main.c, string.h, and string.c.
 The first file (main.c) is provided below, while you will need to implement
 string.h/c.
 The main.c file contains testing code that uses the string you will be implement
ing - it indirectly shows the syntax for the functions.
\end_layout

\begin_layout Standard

\series bold
main.c
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

#include "string.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

    string str, sub_str;
\end_layout

\begin_layout Plain Layout

    str = string_create("this is a string");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    printf("String contents: ");
\end_layout

\begin_layout Plain Layout

    string_display(str);
\end_layout

\begin_layout Plain Layout

    printf("Length: %d
\backslash
n", string_length(str));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    string_append(str, ", I think...");
\end_layout

\begin_layout Plain Layout

    printf("String contents: ");
\end_layout

\begin_layout Plain Layout

    string_display(str);
\end_layout

\begin_layout Plain Layout

    printf("Length: %d
\backslash
n", string_length(str));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    sub_str = string_substring(str, 18, 25);
\end_layout

\begin_layout Plain Layout

    printf("String contents: ");
\end_layout

\begin_layout Plain Layout

    string_display(sub_str);
\end_layout

\begin_layout Plain Layout

    printf("Length: %d
\backslash
n", string_length(sub_str));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    string_destroy(str);
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Output:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

String contents: this is a string
\end_layout

\begin_layout Plain Layout

Length: 16
\end_layout

\begin_layout Plain Layout

String contents: this is a string, I think...
\end_layout

\begin_layout Plain Layout

Length: 28
\end_layout

\begin_layout Plain Layout

String contents: I think
\end_layout

\begin_layout Plain Layout

Length: 7
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 1cm
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch blank
inverted 0
status open

\begin_layout Standard
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard

\series bold
string.h
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#ifndef STRING_H
\end_layout

\begin_layout Plain Layout

#define STRING_H
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#include <stdlib.h>
\end_layout

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//////////////////////////////////////////////////////////////////////
\end_layout

\begin_layout Plain Layout

//Type Definition
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//////////////////////////////////////////////////////////////////////
\end_layout

\begin_layout Plain Layout

//Function Declarations
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//purpose: creates a new string and returns it.
\end_layout

\begin_layout Plain Layout

//return: new string
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//purpose: destroys a string.
\end_layout

\begin_layout Plain Layout

//return: n/a
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//purpose: adds a new string onto the existing string
\end_layout

\begin_layout Plain Layout

//return: n/a
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//purpose: returns the substring of a given string from 
\end_layout

\begin_layout Plain Layout

  the start index (inclusive) to the end index (exclusive).
\end_layout

\begin_layout Plain Layout

//return: new string that is the proper substring
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//purpose: returns the length of the string.
\end_layout

\begin_layout Plain Layout

//return: number of characters in the string
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//purpose: displays the string.
\end_layout

\begin_layout Plain Layout

//return: n/a
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#endif
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard

\series bold
string.c
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//////////////////////////////////////////////////////////////////////
\end_layout

\begin_layout Plain Layout

//Include File
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#include 
\begin_inset Quotes eld
\end_inset

string.h
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//////////////////////////////////////////////////////////////////////
\end_layout

\begin_layout Plain Layout

//Function Declarations
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status open

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard

\series bold
Ans: [Lisonbee]
\end_layout

\begin_layout Standard

\series bold
string.h
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

#include <stdlib.h>
\end_layout

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// STRUCT DECLARATION
\end_layout

\begin_layout Plain Layout

typedef struct string_ADT* string;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// FUNCTION DECLARATIONS
\end_layout

\begin_layout Plain Layout

string string_create(char* str);
\end_layout

\begin_layout Plain Layout

void string_destroy(string str);
\end_layout

\begin_layout Plain Layout

void string_append(string str, char* app);
\end_layout

\begin_layout Plain Layout

string string_substring(string str, int start, int end);
\end_layout

\begin_layout Plain Layout

int string_length(string str);
\end_layout

\begin_layout Plain Layout

void string_display(string str);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace 1cm
\end_inset


\end_layout

\begin_layout Standard

\series bold
string.c
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

#include "string.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

struct string_ADT {
\end_layout

\begin_layout Plain Layout

    char* contents;
\end_layout

\begin_layout Plain Layout

    int length;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//helper function
\end_layout

\begin_layout Plain Layout

int length(char* str) {
\end_layout

\begin_layout Plain Layout

    int count = 0;
\end_layout

\begin_layout Plain Layout

    while (*(str++) != 0)
\end_layout

\begin_layout Plain Layout

        count++;
\end_layout

\begin_layout Plain Layout

    return count;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

string string_create(char* str) {
\end_layout

\begin_layout Plain Layout

    string s = malloc(sizeof(string));
\end_layout

\begin_layout Plain Layout

    s->contents = str;
\end_layout

\begin_layout Plain Layout

    s->length = length(str);
\end_layout

\begin_layout Plain Layout

    return s;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void string_destroy(string str) {
\end_layout

\begin_layout Plain Layout

    free(str->contents);
\end_layout

\begin_layout Plain Layout

    free(str);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void string_append(string str, char* app) {
\end_layout

\begin_layout Plain Layout

    char* buff = malloc(str->length + length(app) + 1);
\end_layout

\begin_layout Plain Layout

    int i;
\end_layout

\begin_layout Plain Layout

    for (i = 0; i < str->length; i++)
\end_layout

\begin_layout Plain Layout

        buff[i] = str->contents[i];
\end_layout

\begin_layout Plain Layout

    for (i = 0; i < length(app); i++)
\end_layout

\begin_layout Plain Layout

        buff[i + str->length] = app[i];
\end_layout

\begin_layout Plain Layout

    buff[i + str->length] = '
\backslash
0';
\end_layout

\begin_layout Plain Layout

    free(str->contents);
\end_layout

\begin_layout Plain Layout

    str->contents = buff;
\end_layout

\begin_layout Plain Layout

    str->length = length(buff);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

string string_substring(string str, int start, int end) {
\end_layout

\begin_layout Plain Layout

    int size = end - start;
\end_layout

\begin_layout Plain Layout

    char* new_str = malloc(size);
\end_layout

\begin_layout Plain Layout

    int i;
\end_layout

\begin_layout Plain Layout

    for (i = 0; i < size; i++)
\end_layout

\begin_layout Plain Layout

        new_str[i] = str->contents[start++];
\end_layout

\begin_layout Plain Layout

    new_str[i] = '
\backslash
0';
\end_layout

\begin_layout Plain Layout

    string result = malloc(sizeof(string));
\end_layout

\begin_layout Plain Layout

    result->contents = new_str;
\end_layout

\begin_layout Plain Layout

    result->length = length(new_str);
\end_layout

\begin_layout Plain Layout

    return result;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int string_length(string str) {
\end_layout

\begin_layout Plain Layout

    return str->length;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void string_display(string str) {
\end_layout

\begin_layout Plain Layout

    printf("%s
\backslash
n", str->contents);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
[Acuña] For 
\series bold
\emph on
stack.
\series default
\emph default
h, select the necessary headers, define the needed structs, and write the
 seven collection functions:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status open

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//////////////////////////////////////////////////////////////////////
\end_layout

\begin_layout Plain Layout

//Include Files
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//////////////////////////////////////////////////////////////////////
\end_layout

\begin_layout Plain Layout

//Macros: Constants
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//////////////////////////////////////////////////////////////////////
\end_layout

\begin_layout Plain Layout

//Type Definitions
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//////////////////////////////////////////////////////////////////////
\end_layout

\begin_layout Plain Layout

//Function Declarations
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//purpose: creates a new stack and returns it.
\end_layout

\begin_layout Plain Layout

//return: error value (zero for success, non-zero for error)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//purpose: destroys a stack.
\end_layout

\begin_layout Plain Layout

//return: n/a
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//purpose: adds an element to the stack
\end_layout

\begin_layout Plain Layout

//return: n/a
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//purpose: returns the most recently added stack element
\end_layout

\begin_layout Plain Layout

//return: error value (zero for success, non-zero for error)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//purpose: returns true if the stack is empty, false otherwise.
\end_layout

\begin_layout Plain Layout

//return value: 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//purpose: returns the size of the size.
\end_layout

\begin_layout Plain Layout

//return: number of elements in the stack
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//purpose: displays the stack.
\end_layout

\begin_layout Plain Layout

//return: n/a
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

#ifndef STACK_H
\end_layout

\begin_layout Plain Layout

#define STACK_H
\end_layout

\begin_layout Plain Layout

//Author(s): Karaliova, Acuna
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//////////////////////////////////////////////////////////////////////
\end_layout

\begin_layout Plain Layout

//Include Files
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//////////////////////////////////////////////////////////////////////
\end_layout

\begin_layout Plain Layout

//Macros: Constants
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//////////////////////////////////////////////////////////////////////
\end_layout

\begin_layout Plain Layout

//Type Definitions
\end_layout

\begin_layout Plain Layout

typedef struct stack stack;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//////////////////////////////////////////////////////////////////////
\end_layout

\begin_layout Plain Layout

//Function Declarations
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//purpose: creates a new stack and returns it.
\end_layout

\begin_layout Plain Layout

//return: error value (zero for success, non-zero for error)
\end_layout

\begin_layout Plain Layout

stack* stack_create(); //can fail (due to memory)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//purpose: destroys a stack.
\end_layout

\begin_layout Plain Layout

//return: n/a
\end_layout

\begin_layout Plain Layout

void stack_destroy(stack** sid);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//purpose: adds an element to the stack
\end_layout

\begin_layout Plain Layout

//return: n/a
\end_layout

\begin_layout Plain Layout

void stack_push(stack* sid, void* data);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//purpose: returns the most recently added stack element
\end_layout

\begin_layout Plain Layout

//return: error value (zero for success, non-zero for error)
\end_layout

\begin_layout Plain Layout

void* stack_pop(stack* sid);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//purpose: returns true if the stack is empty, false otherwise.
\end_layout

\begin_layout Plain Layout

//return value: 
\end_layout

\begin_layout Plain Layout

int stack_is_empty(stack* sid);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//purpose: 
\end_layout

\begin_layout Plain Layout

//return: number of elements in the stack
\end_layout

\begin_layout Plain Layout

int stack_size(stack* sid);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//purpose: 
\end_layout

\begin_layout Plain Layout

//return: n/a
\end_layout

\begin_layout Plain Layout

void stack_display(stack* sid);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#endif
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
[Acuña] For 
\series bold
\emph on
stack.c
\series default
\emph default
, select the necessary headers, define the needed structs, and write the
 seven collection functions:
\end_layout

\begin_deeper
\begin_layout Enumerate
For 
\emph on
stack.c
\emph default
, write code to bring the proper header files:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

//////////////////////////////////////////////////////////////////////
\end_layout

\begin_layout Plain Layout

//Include Files
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

//////////////////////////////////////////////////////////////////////
\end_layout

\begin_layout Plain Layout

//Include Files
\end_layout

\begin_layout Plain Layout

#include <stdio.h> 
\end_layout

\begin_layout Plain Layout

#include <stdlib.h>
\end_layout

\begin_layout Plain Layout

#include "stack.h"
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
For stack.c, define structs for a stack and linked list node.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

//////////////////////////////////////////////////////////////////////
\end_layout

\begin_layout Plain Layout

//Structs
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//////////////////////////////////////////////////////////////////////
\end_layout

\begin_layout Plain Layout

//Functions
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

//////////////////////////////////////////////////////////////////////
\end_layout

\begin_layout Plain Layout

//Structs
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

typedef struct node node;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

struct node {
\end_layout

\begin_layout Plain Layout

	void* element;
\end_layout

\begin_layout Plain Layout

	node* next;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

struct stack {
\end_layout

\begin_layout Plain Layout

	node* head;
\end_layout

\begin_layout Plain Layout

	int size;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//////////////////////////////////////////////////////////////////////
\end_layout

\begin_layout Plain Layout

//Functions
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
For stack.c, implement stack_create.
 This function does not take any parameters but will return a new stack
 collection.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

stack* stack_create() {
\end_layout

\begin_layout Plain Layout

	stack* newStack = (stack*)malloc(sizeof(stack));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	if (newStack == NULL) {
\end_layout

\begin_layout Plain Layout

		printf("Failed to create stack!");
\end_layout

\begin_layout Plain Layout

		exit(0);
\end_layout

\begin_layout Plain Layout

	} else {
\end_layout

\begin_layout Plain Layout

		newStack->head = NULL;
\end_layout

\begin_layout Plain Layout

		newStack->size = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		return newStack;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
For 
\emph on
stack.c
\emph default
, implement
\emph on
 stack_destroy.
 
\emph default
This function should take a stack as a parameter and clean up its memory
 allocation(s).
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

void stack_destroy(stack** sid) {
\end_layout

\begin_layout Plain Layout

	node* iter = (*sid)->head;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	while (iter != NULL) {
\end_layout

\begin_layout Plain Layout

		node* tmp = iter->next;
\end_layout

\begin_layout Plain Layout

		free(iter);
\end_layout

\begin_layout Plain Layout

		iter = tmp;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	free(*sid);
\end_layout

\begin_layout Plain Layout

	*sid = NULL;
\end_layout

\begin_layout Plain Layout

    printf("
\backslash
n All stack elements destroyed");
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
For 
\emph on
stack.c
\emph default
, implement 
\emph on
stack_push
\emph default
.
 This function should take a stack, and an element, as parameters and add
 the element to the top of the stack.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

void stack_push(stack* sid, void* data) {
\end_layout

\begin_layout Plain Layout

	node* newNode = (node*)malloc(sizeof(node));
\end_layout

\begin_layout Plain Layout

    if(newNode == NULL) {
\end_layout

\begin_layout Plain Layout

        printf("Stack: failed to allocation memory for new entry.");
\end_layout

\begin_layout Plain Layout

        exit(0);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

	newNode->element = data;
\end_layout

\begin_layout Plain Layout

	newNode->next = sid->head;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	sid->head = newNode;
\end_layout

\begin_layout Plain Layout

	sid->size++;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
For 
\emph on
stack.c
\emph default
, implement 
\emph on
stack_pop
\emph default
.This function should take a stack as a parameter and return the element
 at the top of the stack.
 The element should be permanently removed from the stack.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

void* stack_pop(stack* sid) {
\end_layout

\begin_layout Plain Layout

    if (sid == NULL || sid->head == NULL)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        printf("
\backslash
n Stack: trying to pop from empty stack.");
\end_layout

\begin_layout Plain Layout

        return NULL;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    else {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    	void* element_var = sid->head->element;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    	sid->head = sid->head->next;
\end_layout

\begin_layout Plain Layout

    	sid->size--;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  	  return element_var;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
In 
\emph on
stack.c
\emph default
, implement 
\emph on
stack_is_empty
\emph default
.
 This function should take a stack as a parameter and return true if it
 contains no elements, and false otherwise.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

int stack_is_empty(stack* sid) {
\end_layout

\begin_layout Plain Layout

	return sid->size == 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
For 
\emph on
stack.c
\emph default
, implement 
\emph on
stack_size
\emph default
.
 This function should return the number of elements in the stack.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

int stack_size(stack* sid) {
\end_layout

\begin_layout Plain Layout

	return sid->size;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
For 
\emph on
stack.c
\emph default
, implement 
\emph on
stack_display
\emph default
.
 This function should display each element in the stack from top to bottom.
 Assume that values are to be displayed as integers.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status collapsed

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $ $
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch soln
inverted 0
status collapsed

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

void stack_display(stack* sid) {
\end_layout

\begin_layout Plain Layout

	node* iter = sid->head;
\end_layout

\begin_layout Plain Layout

    if(iter != NULL) {
\end_layout

\begin_layout Plain Layout

    	printf("(top)
\backslash
n");
\end_layout

\begin_layout Plain Layout

    	while (iter != NULL) {
\end_layout

\begin_layout Plain Layout

    		printf("%d
\backslash
n", (int)iter->element);
\end_layout

\begin_layout Plain Layout

    		iter = iter->next;
\end_layout

\begin_layout Plain Layout

    	}
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    else {
\end_layout

\begin_layout Plain Layout

        printf("Stack is empty
\backslash
n");
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section*
Handling Binary Files
\end_layout

\end_deeper
\begin_layout Enumerate
[Lisonbee] Consider a custom file format for storing experimental data sequentia
lly (binary).
 Knowing only what's given below about this hypothetical file format, implement
 a function that can read this format (using the fread function) and return
 the results from a given trial of an experiment.
\end_layout

\begin_deeper
\begin_layout Itemize
File Header (64 Bytes)
\end_layout

\begin_deeper
\begin_layout Itemize
File size (64 Bytes)
\end_layout

\end_deeper
\begin_layout Itemize
Experimental Header (40 Bytes)
\end_layout

\begin_deeper
\begin_layout Itemize
Number of experiments (16 Bytes)
\end_layout

\begin_layout Itemize
Number of trials per experiment (8 Bytes)
\end_layout

\begin_layout Itemize
Size of trial data (16 Bytes)
\end_layout

\end_deeper
\begin_layout Itemize
Experimental Data (2D array based on number of experiments and trials per
 experiment)
\end_layout

\begin_deeper
\begin_layout Itemize
Each row begins with the experiment ID (16 Bytes), followed by the data
 from each successive trial (16 Bytes)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Branch blank
inverted 0
status open

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

uint16_t get_results(FILE* file_in, uint16_t experiment_ID, uint16_t trial_num)
 {
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Branch soln
inverted 0
status open

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

uint16_t get_results(FILE* file_in, uint16_t experiment_ID, uint16_t trial_num)
 {
\end_layout

\begin_layout Plain Layout

    uint16_t width, height, size, result;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    //read file header
\end_layout

\begin_layout Plain Layout

    fread(NULL, sizeof(uint64_t), 1, file_in);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    //read experimental header
\end_layout

\begin_layout Plain Layout

    fread(&height, sizeof(uint16_t), 1, file_in);
\end_layout

\begin_layout Plain Layout

    fread(&width, sizeof(uint8_t), 1, file_in);
\end_layout

\begin_layout Plain Layout

    fread(&size, sizeof(uint16_t), 1, file_in);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    //read experimental data
\end_layout

\begin_layout Plain Layout

    int i, j;
\end_layout

\begin_layout Plain Layout

    for (i = 0; i < height; i++) {
\end_layout

\begin_layout Plain Layout

        fread(&result, sizeof(uint16_t), 1, file_in);
\end_layout

\begin_layout Plain Layout

            if (result == experiment_ID) {
\end_layout

\begin_layout Plain Layout

                for (j = 0; j < width; j++) {
\end_layout

\begin_layout Plain Layout

                    fread(&result, sizeof(uint16_t), 1, file_in);
\end_layout

\begin_layout Plain Layout

                        if (trial_num == j)
\end_layout

\begin_layout Plain Layout

                            return result;
\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return 0; //if the data isn't found
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\end_body
\end_document
